(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{428:function(t,e,a){"use strict";a.r(e);var r=a(2),n=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"algorithm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#algorithm"}},[t._v("#")]),t._v(" Algorithm：")]),t._v(" "),e("h4",{attrs:{id:"_114-二叉树展开为链表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_114-二叉树展开为链表"}},[t._v("#")]),t._v(" "),e("a",{attrs:{href:"https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/",target:"_blank",rel:"noopener noreferrer"}},[t._v("114. 二叉树展开为链表"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("解题思路：")]),t._v(" "),e("p",[t._v("可以发现展开的顺序其实就是二叉树的先序遍历。")]),t._v(" "),e("ol",[e("li",[t._v("将左子树插入到右子树的地方")]),t._v(" "),e("li",[t._v("将原来的右子树接到左子树的最右边节点")]),t._v(" "),e("li",[t._v("考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null")])]),t._v(" "),e("p",[t._v("还有一种是利用了前序遍历，将树节点依次放入数组，然后再利用数组组成链表。")]),t._v(" "),e("h4",{attrs:{id:"_1208-尽可能使字符串相等"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1208-尽可能使字符串相等"}},[t._v("#")]),t._v(" "),e("a",{attrs:{href:"https://leetcode.cn/problems/get-equal-substrings-within-budget/",target:"_blank",rel:"noopener noreferrer"}},[t._v("1208. 尽可能使字符串相等"),e("OutboundLink")],1)]),t._v(" "),e("h4",{attrs:{id:"前缀和-二分查找"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前缀和-二分查找"}},[t._v("#")]),t._v(" 前缀和 + 二分查找")]),t._v(" "),e("p",[t._v("利用前缀和记录两个字符串到第i个位置所消费的总开销。利用 前缀和 - 第i个节点中间的开销小于等于预算。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("accDiff[i] - accDiff[start] <= maxCost\n\naccDiff[i] - maxCost <= accDiff[start]\n")])])]),e("p",[t._v("根据等式，在start - i 中找到  accDiff[i] - maxCost 的最大值。并返回start。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function equalSubstring(s: string, t: string, maxCost: number): number {\n    const n = s.length;\n    // 记录前缀和\n    const  accDiff = new Array(n + 1).fill(0)\n    for(let i = 0; i < n; i++) {\n        accDiff[i+1] = accDiff[i] + Math.abs(s[i].charCodeAt(0)- t[i].charCodeAt(0));\n    }\n    let maxLength = 0;\n    for(let j = 1; j < accDiff.length; j++) {\n        const start = binarySearch(accDiff, j, accDiff[j] - maxCost)\n        maxLength = Math.max(maxLength, j - start)\n    }\n    return maxLength\n};\nfunction binarySearch (accDiff: number[], endIndex: number, target: number): number {\n    let low = 0;\n    let high = endIndex;\n    while(low < high) {\n        let mid = Math.floor((low + high) / 2)\n        if(accDiff[mid] < target) {\n            low = mid + 1\n        }else {\n            high = mid\n        }\n    }\n    return low;\n\n}\n")])])]),e("h2",{attrs:{id:"review-使用-typescript-从字符串文字类型中提取参数类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#review-使用-typescript-从字符串文字类型中提取参数类型"}},[t._v("#")]),t._v(" Review："),e("a",{attrs:{href:"https://lihautan.com/extract-parameters-type-from-string-literal-types-with-typescript/#removing-the-brackets",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用 TypeScript 从字符串文字类型中提取参数类型"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("主要介绍了ts4.1的"),e("a",{attrs:{href:"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types",target:"_blank",rel:"noopener noreferrer"}},[t._v("Template Literal Types"),e("OutboundLink")],1),t._v("和"),e("a",{attrs:{href:"https://lihautan.com/extract-parameters-type-from-string-literal-types-with-typescript/#conditional-type",target:"_blank",rel:"noopener noreferrer"}},[t._v("Conditional Type"),e("OutboundLink")],1),t._v("Conditional Type")]),t._v(" "),e("p",[t._v("Template Literal Types在开发中主要用于枚举常量。Conditional Type主要应用于不同场景下的ts类型。")]),t._v(" "),e("p",[t._v("最后react router 中对于route的path，params也是利用这个两个ts类型实现。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 提取参数类型\n// type IsParameter<Part> = Part extends `[${infer ParamName}]` ? Part : never\n// 去除[]\ntype IsParameter<Part> = Part extends `[${infer ParamName}]` ? ParamName : never\n// 进行condition type判断 利用递归将多个参数类型进行提取\ntype FilteredParts<Path> = Path extends `${infer PartA}/${infer PartB}` ?  IsParameter<PartA> | FilteredParts<PartB> : IsParameter<Path>\n// 将path类型映射成对象\n// type Params<Path> = {\n//   [key in FilteredParts<Path>]: any\n// }\n// 将condition type区分参数类型\ntype ParamValue<Key> = Key extends `...${infer Anything}` ? string[] : number;\n// type Params<Path> = {\n//   [Key in FilteredParts<Path>]: ParamValue<Key>\n// }\ntype RemovePrefixDots<Key> = Key extends `...${infer Name}` ? Name : Key\ntype Params<Path> = {\n  [Key in FilteredParts<Path> as RemovePrefixDots<Key>]: ParamValue<Key>\n}\ntype Path = Params<'/purchase/[shopid]/[itemid]/args/[...args]'>\n")])])]),e("h2",{attrs:{id:"tips-css-browser-support"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tips-css-browser-support"}},[t._v("#")]),t._v(" Tips："),e("a",{attrs:{href:"https://github.com/5t3ph/css-browser-support",target:"_blank",rel:"noopener noreferrer"}},[t._v("css-browser-support"),e("OutboundLink")],1)]),t._v(" "),e("blockquote",[e("p",[t._v("使用 caniuse.com 和 MDN 查询 CSS 浏览器支持情况 — 传递字符串或者字符串数组作为参数进行查询，返回不同浏览器支持的结果")])]),t._v(" "),e("p",[t._v("可以对css样式的浏览器兼容进行查看并对其添加其他css特性。")]),t._v(" "),e("h3",{attrs:{id:"在react-router中使用动画"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在react-router中使用动画"}},[t._v("#")]),t._v(" 在React-Router中使用动画")]),t._v(" "),e("p",[t._v("用的库是react官方推荐的 "),e("a",{attrs:{href:"https://reactcommunity.org/react-transition-group/",target:"_blank",rel:"noopener noreferrer"}},[t._v("React Transition Group"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("cssTransition 的属性 key需要配合react-route-dom的useLocation,但是出现下面的报错")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("React js: Error: useLocation() may be used only in the context of a <Router> component\n")])])]),e("p",[t._v("解决方案")]),t._v(" "),e("p",[t._v("使用"),e("code",[t._v("useLocation()")]),t._v("需要在"),e("code",[t._v("<Router>")]),t._v("的全局上下文"),e("code",[t._v("context")]),t._v("使用，所以需要在根组件"),e("code",[t._v("<App>")]),t._v("外面添加"),e("code",[t._v("<Router>")]),t._v("，才能在"),e("code",[t._v("<App>")]),t._v("中使用"),e("code",[t._v("useLocation()")]),t._v("。")])])}),[],!1,null,null,null);e.default=n.exports}}]);