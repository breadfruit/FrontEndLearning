(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{434:function(e,n,t){"use strict";t.r(n);var a=t(2),r=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"algorithm"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#algorithm"}},[e._v("#")]),e._v(" Algorithm")]),e._v(" "),n("h4",{attrs:{id:"_384-打乱数组"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_384-打乱数组"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://leetcode.cn/problems/shuffle-an-array/",target:"_blank",rel:"noopener noreferrer"}},[e._v("384. 打乱数组"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("解题思路：")]),e._v(" "),n("p",[e._v("我们可以在移除waiting 的第 k 个元素时，将第 k 个元素与数组的最后 1个元素交换，然后移除交换后数组的最后 1个元素，这样我们只需要 O(1) 的时间复杂度即可完成移除第 k 个元素的操作。此时，被移除的交换后数组的最后 1 个元素即为我们根据随机下标获取的元素。")]),e._v(" "),n("p",[e._v("具体地，实现算法如下：")]),e._v(" "),n("p",[e._v("设待原地乱序的数组 nums。\n循环 n次，在第 i 次循环中（0≤i<n）：\n在 [i,n) 中随机抽取一个下标 j；\n将第 i 个元素与第 j 个元素交换。\n其中数组中的 nums[i .. n−1] 的部分为待乱序的数组，其长度为 n-i; nums[0 .. i−1] 的部分为乱序后的数组，其长度为 i。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Solution {\n    private nums: number[]\n    constructor(nums: number[]) {\n        this.nums = nums;\n    }\n\n    reset(): number[] {\n        return this.nums;\n    }\n\n    shuffle(): number[] {\n        let newNum = this.nums.slice();\n        for(let i = 0; i < newNum.length; i++) {\n            this.swap(newNum, i, Math.floor(Math.random()*(this.nums.length - i)+i))\n        }\n        return newNum\n    }\n    swap(newNum, i, j) {\n        return [newNum[i], newNum[j]] =  [newNum[j], newNum[i]]\n    }\n    \n}\n")])])]),n("p",[e._v("具体的，我们从前往后尝试填充 [0, n - 1][0,n−1] 该填入什么数时，通过随机当前下标与**（剩余的）哪个下标**进行值交换来实现。")]),e._v(" "),n("h4",{attrs:{id:"_146-lru-缓存"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_146-lru-缓存"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://leetcode.cn/problems/lru-cache/",target:"_blank",rel:"noopener noreferrer"}},[e._v("146. LRU 缓存"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。\n实现 LRUCache 类：\nLRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存\nint get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\nvoid put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。\n函数 get 和 put 必须以 O(1) 的平均时间复杂度运行")]),e._v(" "),n("p",[e._v("解题思路：")]),e._v(" "),n("ol",[n("li",[e._v("LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。")])]),e._v(" "),n("p",[e._v("双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。")]),e._v(" "),n("p",[e._v("哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。")]),e._v(" "),n("p",[e._v("这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1)的时间内完成 get 或者 put 操作。具体的方法如下：")]),e._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[e._v("对于 get 操作，首先判断 key 是否存在：")])]),e._v(" "),n("p",[e._v("如果 key 不存在，则返回 -1；")]),e._v(" "),n("p",[e._v("如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。")]),e._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[e._v("对于 put 操作，首先判断 key 是否存在：")])]),e._v(" "),n("p",[e._v("如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；")]),e._v(" "),n("p",[e._v("如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。")]),e._v(" "),n("p",[e._v("优化：")]),e._v(" "),n("ol",[n("li",[e._v("可以在添加节点和删除尾节点对哈希表进行更新。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/**\n * @param {number} capacity\n */\nclass ListNode {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n        this.pre = null;\n        this.next = null;\n    }\n}\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.count = 0;\n    this.dic = {};\n    this.dummaryHead = new ListNode();\n    this.dummaryTail = new ListNode();\n    this.dummaryHead.next = this.dummaryTail;\n    this.dummaryTail.pre = this.dummaryHead ;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    let targerNode = this.dic[key];\n    if(targerNode == null) return -1;\n    this.moveToHead(targerNode)\n    return targerNode.value;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if(this.dic[key]) {\n        let node = this.dic[key];\n        node.value = value;\n        this.moveToHead(node)\n    }else{\n        let node = new ListNode(key, value);\n        if(this.count < this.capacity) {\n            this.dic[key] = node;\n            this.addToHead(node);\n            this.count++;\n        }else{\n            this.removeTail();\n            this.dic[key] = node;\n            this.addToHead(node);\n        }\n    }\n};\n\nLRUCache.prototype.moveToHead = function(node) {\n    this.removeSelf(node);\n    this.addToHead(node);\n}\n\nLRUCache.prototype.removeSelf = function(node) {\n    node.pre.next = node.next;\n    node.next.pre = node.pre;\n    node.next = null;\n    node.pre = null;\n}\n\nLRUCache.prototype.addToHead = function(node) {\n    node.pre = this.dummaryHead;\n    node.next = this.dummaryHead.next;\n    this.dummaryHead.next.pre = node;\n    this.dummaryHead.next = node;\n    \n}\n\nLRUCache.prototype.removeTail= function() {\n    let node = this.dummaryTail.pre;\n    this.removeSelf(node);\n    delete this.dic[node.key];\n}\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n")])])]),n("h2",{attrs:{id:"notes-on-maintaining-an-internal-react-component-library"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#notes-on-maintaining-an-internal-react-component-library"}},[e._v("#")]),e._v(" "),n("a",{attrs:{href:"https://www.gabe.pizza/notes-on-component-libraries/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Notes on maintaining an internal React component library"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("这篇文章主要写在维护React组件库的时候应该注意的。")]),e._v(" "),n("ol",[n("li",[e._v("简介表示组件提供的接口。")]),e._v(" "),n("li",[e._v("组件中不应该有空格，最好采用响应式布局(grid, flex等)")]),e._v(" "),n("li",[e._v("组件可能不应该定位它们自己。")]),e._v(" "),n("li",[e._v("组件不应该暴露"),n("code",[e._v("className")]),e._v(" or "),n("code",[e._v("style")]),e._v(" props.应该是"),n("code",[e._v("UNSAFE_className")]),e._v(" and "),n("code",[e._v("UNSAFE_style")])]),e._v(" "),n("li",[e._v("组件在继承基类的时候，需要考虑所有的属性，最好用...扩展符；")]),e._v(" "),n("li",[e._v("将逻辑组件(list: listitem; select: SelectMenu,SelectOption)作为一个对象统一管理")])]),e._v(" "),n("h2",{attrs:{id:"tip-click-to-component"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tip-click-to-component"}},[e._v("#")]),e._v(" Tip： "),n("a",{attrs:{href:"https://github.com/ericclemmons/click-to-component",target:"_blank",rel:"noopener noreferrer"}},[e._v("click-to-component"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("一个快速点击视图上点击跳转到相应的组件代码位置，比devtools找组件方便多了。项目中有案例，乐意在vite，next等使用。")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("Option+Click opens the immediate Component's source")])]),e._v(" "),n("li",[n("p",[e._v("Option+Right-click opens a context menu with the parent Components' "),n("code",[e._v("props")]),e._v(", "),n("code",[e._v("fileName")]),e._v(", "),n("code",[e._v("columnNumber")]),e._v(", and "),n("code",[e._v("lineNumber")])]),e._v(" "),n("blockquote",[n("p",[n("a",{attrs:{href:"https://github.com/ericclemmons/click-to-component/blob/main/.github/props.png",target:"_blank",rel:"noopener noreferrer"}},[n("img",{attrs:{src:"https://github.com/ericclemmons/click-to-component/raw/main/.github/props.png",alt:"props"}}),n("OutboundLink")],1)])])]),e._v(" "),n("li",[n("p",[e._v("Works with frameworks like "),n("a",{attrs:{href:"https://nextjs.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Next.js"),n("OutboundLink")],1),e._v(", "),n("a",{attrs:{href:"https://create-react-app.dev/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Create React App"),n("OutboundLink")],1),e._v(", & "),n("a",{attrs:{href:"https://github.com/vitejs/vite/tree/main/packages/plugin-react",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vite"),n("OutboundLink")],1),e._v(" that use "),n("a",{attrs:{href:"https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-react-jsx-source",target:"_blank",rel:"noopener noreferrer"}},[e._v("@babel/plugin-transform-react-jsx-source"),n("OutboundLink")],1)])]),e._v(" "),n("li",[n("p",[e._v("Supports "),n("code",[e._v("vscode")]),e._v(" & "),n("code",[e._v("vscode-insiders")]),e._v("' "),n("a",{attrs:{href:"https://code.visualstudio.com/docs/editor/command-line#_opening-vs-code-with-urls",target:"_blank",rel:"noopener noreferrer"}},[e._v("URL handling"),n("OutboundLink")],1)])]),e._v(" "),n("li",[n("p",[e._v("Automatically "),n("strong",[e._v("tree-shaken")]),e._v(" from "),n("code",[e._v("production")]),e._v(" builds")])]),e._v(" "),n("li",[n("p",[e._v("Keyboard navigation in context menu (e.g. ←, →, ⏎)")])]),e._v(" "),n("li",[n("p",[e._v("More context & faster than using React DevTools:")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);