(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{443:function(t,e,r){"use strict";r.r(e);var a=r(2),n=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"algorithm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#algorithm"}},[t._v("#")]),t._v(" Algorithm：")]),t._v(" "),e("h4",{attrs:{id:"_845-数组中的最长山脉"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_845-数组中的最长山脉"}},[t._v("#")]),t._v(" "),e("a",{attrs:{href:"https://leetcode.cn/problems/longest-mountain-in-array/",target:"_blank",rel:"noopener noreferrer"}},[t._v("845. 数组中的最长山脉"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("解题思路：")]),t._v(" "),e("p",[t._v("我们可以考虑枚举山顶，再从山顶向左右两侧扩展找到山脚。两边从山脚到山顶可以利用动画规划left[i]/rught[i]进行存储当前左右山脚到山顶最长的长度。转化方程：")]),t._v(" "),e("ol",[e("li",[t._v("左山脚到山顶，当left[[i] > left[i-1] ,则left[i] = left[i-1] + 1反之0")]),t._v(" "),e("li",[t._v("右山脚到山顶，当right[i] > right[i+1] ,则right[i] = right[i+1] + 1反之0")])]),t._v(" "),e("p",[t._v("注意⚠️")]),t._v(" "),e("ol",[e("li",[t._v("左山脚只能到arr[n-2],右山脚只能到1，因为山顶要有左右山脚。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function longestMountain(arr: number[]): number {\n    let ans = 0;\n    let n = arr.length;\n    let left = new Array(n).fill(0);\n    for(let i = 1; i < arr.length; i++) {\n        left[i] = arr[i] > arr[i-1] ? left[i-1] + 1 : 0;\n    }\n    let right = new Array(n).fill(0);\n    for(let i = n - 2 ; i > 0; i--) {\n        right[i] = arr[i] > arr[i+1] ? right[i+1] + 1 : 0;\n    }\n    for(let z = 0; z < n; z++) {\n        if(right[z] > 0 && left[z] > 0) {\n            ans = Math.max(right[z] + left[z] + 1, ans);\n        }\n    }\n    return ans;\n};\n")])])]),e("h4",{attrs:{id:"_12-整数转罗马数字"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-整数转罗马数字"}},[t._v("#")]),t._v(" "),e("a",{attrs:{href:"https://leetcode.cn/problems/integer-to-roman/",target:"_blank",rel:"noopener noreferrer"}},[t._v("12. 整数转罗马数字"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("解题思路：\n给定一个数字，模拟出由罗马数字可能组成的组合，并从大到小排序。然后依次寻找不超过num 的最大符号值，放入数组并返回字符串。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var intToRoman = function(num) {\n    const valueSymbols: Array<[number, string]> = [[1000, "M"], [900, "CM"], [500, "D"], [400, "CD"], [100, "C"], [90, "XC"], [50, "L"], [40, "XL"], [10, "X"], [9, "IX"], [5, "V"], [4, "IV"], [1, "I"]];\n    const roman = [];\n    for(const [value, symbol] of valueSymbols) {\n        while (num >= value) {\n            num -= value;\n            roman.push(symbol);\n        }\n        if(num == 0) break\n    }\n    return roman.join(\'\');\n};\n')])])]),e("h2",{attrs:{id:"review-ecma-international-approves-ecmascript-2022-what-s-new"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#review-ecma-international-approves-ecmascript-2022-what-s-new"}},[t._v("#")]),t._v(" Review："),e("a",{attrs:{href:"https://2ality.com/2022/06/ecmascript-2022.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Ecma International approves ECMAScript 2022: What’s new?"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("ES2022新增：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("class新增了类字段，static字段和私有属性。\n![image-20220630225429952](/Users/macos/Library/Application Support/typora-user-images/image-20220630225429952.png)")])]),t._v(" "),e("li",[e("p",[t._v("await")])])]),t._v(" "),e("p",[t._v("相比之前，await只能在async之内使用，现在新增可以在模块的顶部直接使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const response = await fetch('https://example.com');\nconst text = await response.text();\nconsole.log(text);\n")])])]),e("p",[t._v("解决了什么问题？：")]),t._v(" "),e("ol",[e("li",[t._v("可以不用(async () => {await fetch()}),直接使用await fetch();")]),t._v(" "),e("li",[t._v("模块之间进行导入导出，会遇到当前导出的值需要借助异步函数进行取值然后进行导出，利用立即执行函数的话不能判断当地promise的状态，只能通过promise的then回调进行在加载执行完进行导出，因此之前的方案是导出一个prmoise对象,从then判断异步操作有没有结束。现在之间可以在导出模块进行内部协调。")])]),t._v(" "),e("p",[t._v("参考： "),e("a",{attrs:{href:"https://www.bookstack.cn/read/es6-3rd/spilt.7.docs-async.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"tips-react-joyride-在您的应用程序中创建导览"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tips-react-joyride-在您的应用程序中创建导览"}},[t._v("#")]),t._v(" Tips："),e("a",{attrs:{href:"https://github.com/gilbarbara/react-joyride",target:"_blank",rel:"noopener noreferrer"}},[t._v("React Joyride：在您的应用程序中创建导览"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("该库使用 react-floater 来定位和设置浮动“导览”元素的样式。在平时的应用中，新手指引就会用到导览，通过step指引介绍部分功能。")]),t._v(" "),e("h2",{attrs:{id:"reactime-v14-0-用于在-react-应用程序中进行-debugging-的-chrome-开发者工具"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reactime-v14-0-用于在-react-应用程序中进行-debugging-的-chrome-开发者工具"}},[t._v("#")]),t._v(" "),e("a",{attrs:{href:"https://github.com/open-source-labs/reactime/releases/tag/v14.0.0",target:"_blank",rel:"noopener noreferrer"}},[t._v("Reactime v14.0：用于在 React 应用程序中进行 Debugging 的 Chrome 开发者工具"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("这个插件实现了：")]),t._v(" "),e("ol",[e("li",[t._v("记录各种路由快照记录，可以穿越不同不同查看情况。")]),t._v(" "),e("li",[t._v("按路由进行分类，可以快速找到目标路由的情况。")]),t._v(" "),e("li",[t._v("查看路由的渲染性能指标，可以通过条形图查看性能数据。")])])])}),[],!1,null,null,null);e.default=n.exports}}]);