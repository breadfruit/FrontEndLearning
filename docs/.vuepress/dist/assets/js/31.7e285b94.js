(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{437:function(e,t,r){"use strict";r.r(t);var n=r(3),a=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"algorithm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#algorithm"}},[e._v("#")]),e._v(" Algorithm：")]),e._v(" "),t("h4",{attrs:{id:"_226-翻转二叉树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_226-翻转二叉树"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://leetcode.cn/problems/invert-binary-tree/",target:"_blank",rel:"noopener noreferrer"}},[e._v("226. 翻转二叉树"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("解题思路：")]),e._v(" "),t("p",[e._v("将二叉树进行深度遍历，注意题目所示，左右子树进行翻转。如果当前遍历到的节点root 的左右两棵子树都已经翻转(利用深度搜素进行自下而上)，那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function invertTree(root: TreeNode | null): TreeNode | null {\n        if(!root) return null\n        let rootLeft = invertTree(root.left);\n        let rootRight = invertTree(root.right);\n        root.left =  rootRight;\n        root.right = rootLeft;\n        return root\n};\n")])])]),t("p",[e._v("复杂度分析")]),e._v(" "),t("p",[e._v("时间复杂度：O(n)，其中 n 为二叉树的节点个数。")]),e._v(" "),t("p",[e._v("空间复杂度：O(n)，其中 n 为二叉树(递归栈/函数栈)的深度。")]),e._v(" "),t("h4",{attrs:{id:"_229-多数元素-ii"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_229-多数元素-ii"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://leetcode.cn/problems/majority-element-ii/",target:"_blank",rel:"noopener noreferrer"}},[e._v("229. 多数元素 II"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("解题思路：")]),e._v(" "),t("p",[e._v("利用哈希值将遍历过程中数字出现的次数进行记录，记录超过数组长度为n的且超过 n / 3的数，可以说是不会超过3个，也就是说最多两个。最后返回所有统计次数超过floor⌊3"),t("em",[e._v("n")]),e._v("⌋ 的元素。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function majorityElement(nums: number[]): number[] {\n    let map = new Map<number, number>();\n    for(let i =0; i < nums.length; i ++){\n        if(map.has(nums[i])) {\n            map.set(nums[i], map.get(nums[i]) + 1);\n        }else{\n            map.set(nums[i], 1);\n        }\n    }\n    let res = [];\n    let tagetLen = Math.floor(nums.length / 3);\n    for(let e of map.entries()) {\n        if(e[1] > tagetLen) {\n            res.push(e[0])\n        }\n    }\n    return res;\n}\n")])])]),t("p",[e._v("复杂度分析")]),e._v(" "),t("p",[e._v("时间复杂度：O(n)，其中 nn 为数组的长度。")]),e._v(" "),t("p",[e._v("空间复杂度：O(n)，其中 nn 为数组的长度，使用哈希表需要开辟额外的空间。")]),e._v(" "),t("h2",{attrs:{id:"review-react-folder-structure-in-5-steps-2022"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#review-react-folder-structure-in-5-steps-2022"}},[e._v("#")]),e._v(" Review："),t("a",{attrs:{href:"https://blog.bitsrc.io/understanding-referential-equality-in-react-a8fb3769be0",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Folder Structure in 5 Steps [2022]"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("在建立一个大型的react应用，如何去管理的项目文件夹，对于自己平时没有很少做到的事以下几点：")]),e._v(" "),t("ol",[t("li",[e._v("将常用的组件和ui组件分开 ，components / features")]),e._v(" "),t("li",[e._v("将钩子， context 和其他文件分开，hooks ，components / features")]),e._v(" "),t("li",[e._v("对于工具类函数，辅助性的函数归纳于services(utils)")])]),e._v(" "),t("h2",{attrs:{id:"tips-react-holmes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tips-react-holmes"}},[e._v("#")]),e._v(" Tips: "),t("a",{attrs:{href:"https://devx-os.github.io/react-holmes/",target:"_blank",rel:"noopener noreferrer"}},[e._v("react-holmes"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v('Holmes 声称只有一个目标：“使状态管理尽可能简单和快速"。')]),e._v(" "),t("p",[e._v("React 对于组件之间的数据状态管理的方案是将组件数据状态的独立性，如果要将个组件之间的数据进行通信，通过将该数据挂于全局上下文(useContext)进行通信，而react-homeles是利用观察observe，")]),e._v(" "),t("ol",[t("li",[e._v("应用程序状态分散在组件之间，使其在应用程序的每个部分都可以访问。")]),e._v(" "),t("li",[e._v("组件将共享状态的本地副本和修改它的回调。每次更新都会向订阅相同状态的组件发送事件。")]),e._v(" "),t("li",[e._v("快速和简单")])])])}),[],!1,null,null,null);t.default=a.exports}}]);