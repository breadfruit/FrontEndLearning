(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{418:function(t,r,e){t.exports=e.p+"assets/img/week31.dd336b2c.jpg"},461:function(t,r,e){"use strict";e.r(r);var a=e(2),s=Object(a.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"algorithm"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#algorithm"}},[t._v("#")]),t._v(" Algorithm")]),t._v(" "),r("p",[r("img",{attrs:{src:e(418),alt:"An image"}})]),t._v(" "),r("p",[t._v("其中"),r("a",{attrs:{href:"https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solutions/",target:"_blank",rel:"noopener noreferrer"}},[t._v("二叉搜索树与双向链表"),r("OutboundLink")],1),t._v("\n在对二叉树进行遍历的时候进行实现双向链表是值得推敲的。")]),t._v(" "),r("p",[t._v("将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：")]),t._v(" "),r("p",[t._v("排序链表： 节点应从小到大排序，因此应使用 中序遍历 “从小到大”访问树的节点。\n双向链表： 在构建相邻节点的引用关系时，设前驱节点 pre 和当前节点 cur ，不仅应构建 pre.right = cur ，也应构建 cur.left = pre 。\n循环链表： 设链表头节点 head 和尾节点 tail ，则应构建 head.left = tail 和 tail.right = head")]),t._v(" "),r("h2",{attrs:{id:"tips"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tips"}},[t._v("#")]),t._v(" Tips")]),t._v(" "),r("p",[r("strong",[r("a",{attrs:{href:"https://github.com/ehmicky/wild-wild-path",target:"_blank",rel:"noopener noreferrer"}},[t._v("Wild Wild Path：带有通配符和正则表达式的对象属性路径"),r("OutboundLink")],1)]),t._v("\n 基于通配符和正则表达式实现对象字符串查询（可以深度嵌套）。")])])}),[],!1,null,null,null);r.default=s.exports}}]);