(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{438:function(t,e,a){"use strict";a.r(e);var r=a(2),n=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h4",{attrs:{id:"本周-aart"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#本周-aart"}},[t._v("#")]),t._v(" 本周 AART")]),t._v(" "),e("ul",[e("li",[t._v("A: 两数相加")]),t._v(" "),e("li",[t._v("A: 无重复字符的最长子串")]),t._v(" "),e("li",[t._v("R: Base: An Acid Alternative")]),t._v(" "),e("li",[t._v("T: 编程时如何命名")])]),t._v(" "),e("h1",{attrs:{id:"algorithm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#algorithm"}},[t._v("#")]),t._v(" Algorithm：")]),t._v(" "),e("h2",{attrs:{id:"_2-两数相加"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-两数相加"}},[t._v("#")]),t._v(" "),e("a",{attrs:{href:"https://leetcode.cn/problems/add-two-numbers/",target:"_blank",rel:"noopener noreferrer"}},[t._v("2. 两数相加"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。")]),t._v(" "),e("p",[t._v("请你将两个数相加，并以相同形式返回一个表示和的链表。")]),t._v(" "),e("p",[t._v("你可以假设除了数字 0 之外，这两个数都不会以 0 开头。")]),t._v(" "),e("h3",{attrs:{id:"思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#思路"}},[t._v("#")]),t._v(" 思路")]),t._v(" "),e("p",[t._v("题目是两链表进行相加，利用双指针的方式，一个指向新链表的头部，一个随着遍历链表进行移动，在将两个链表当前的节点进行相加的时候，需要用一个变量来标志进位符，当前的和大于9，就将进位符设为1，反之为0。这里需要注意的是两个个为相加是不会大于18的。需要考虑的边界情况：")]),t._v(" "),e("ol",[e("li",[t._v("头尾指针刚开始指向两链表首节点之和。")]),t._v(" "),e("li",[t._v("当遍历到最后一个节点的时候，需要判断进位符。")])]),t._v(" "),e("h3",{attrs:{id:"代码思想"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码思想"}},[t._v("#")]),t._v(" 代码思想：")]),t._v(" "),e("ol",[e("li",[t._v("链表的移动：head.next = 新值； head = head.next;")]),t._v(" "),e("li",[t._v("两链表的长度不同是，值设为0。const x1 = l1 ? la.val : 0")]),t._v(" "),e("li",[t._v("保留当前和的余数(sum % 10)，进位符保留当前和的整除数(0或者1)")])]),t._v(" "),e("h3",{attrs:{id:"解题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解题"}},[t._v("#")]),t._v(" 解题")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    let dummyHead = new ListNode();\n    let prev = dummyHead;\n    let add = 0;\n    while (l2 || l1 || add > 0) {\n        var a : number = 0\n        var b : number = 0\n        if (l1) {\n             a = l1.val\n             l1 = l1.next\n        }\n        if (l2) {\n            b = l2.val\n            l2 = l2.next\n        }\n        const sum = a + b + add;\n        prev.next = new ListNode(sum % 10);\n        add = Math.floor(sum / 10);\n        prev = prev.next;\n    }\n\n    return dummyHead.next;\n};\n")])])]),e("h2",{attrs:{id:"_3-无重复字符的最长子串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-无重复字符的最长子串"}},[t._v("#")]),t._v(" "),e("a",{attrs:{href:"https://leetcode.cn/problems/longest-substring-without-repeating-characters/",target:"_blank",rel:"noopener noreferrer"}},[t._v("3. 无重复字符的最长子串"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("给定一个字符串 "),e("code",[t._v("s")]),t._v(" ，请你找出其中不含有重复字符的 "),e("strong",[t._v("最长子串")]),t._v(" 的长度。")]),t._v(" "),e("h3",{attrs:{id:"思路-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#思路-2"}},[t._v("#")]),t._v(" 思路")]),t._v(" "),e("p",[t._v("这道题主要看两个关键词： 无重复 ，最长。无重复可以用到数据结构set，记录当前的值。最长则用Math.max()数学函数取得最大值。")]),t._v(" "),e("p",[t._v("子串是连续的，这里可以用到滑动窗口，其实就是两个指针，一个维护左边的边界，一个维护右边的边界。两个指针之间的距离就是我们子串的距离。那么最长就是在每次的滑动中保留最长的那个。那么什么时候需要去移动左右指针？左右指针什么时候又停止移动？")]),t._v(" "),e("p",[t._v("需要考虑的边界问题：")]),t._v(" "),e("ol",[e("li",[t._v("每次去移动右指针的时候，需要判断是否重复，重复则移动左指针，并且删除集合set中的值。")]),t._v(" "),e("li",[t._v("右指针不能超过字符串长度，左指针小于等于右指针。")])]),t._v(" "),e("h3",{attrs:{id:"解题-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解题-2"}},[t._v("#")]),t._v(" 解题")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function lengthOfLongestSubstring(s: string): number {\n    let left= 0\n    let right = 0\n    let res = 0\n    let len = s.length\n    let set = new Set()\n    while(right < len && left < len) {\n        while(set.has(s[right]) && left < len) {\n            set.delete(s[left])\n            left ++;\n        }\n        set.add(s[right])\n        res = Math.max(res, right - left + 1)\n        right ++\n    }\n    return res\n};\n")])])]),e("h1",{attrs:{id:"review"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#review"}},[t._v("#")]),t._v(" Review")]),t._v(" "),e("h2",{attrs:{id:"progressive-image-loading-in-react-tutorial"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#progressive-image-loading-in-react-tutorial"}},[t._v("#")]),t._v(" Progressive image loading in React: Tutorial")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.logrocket.com/progressive-image-loading-react-tutorial/",target:"_blank",rel:"noopener noreferrer"}},[t._v("主题：React 中的渐进式图像加载"),e("OutboundLink")],1)]),t._v(" "),e("ol",[e("li",[t._v("可以通过给图片进行设置宽高，以便可以快速加载，浏览器布局可以不用去计算图片需要多少的加载时间。")]),t._v(" "),e("li",[t._v("为图片设置缩略图 -> 实际图片，用useEffect进行对图片的src属性进行监听。")]),t._v(" "),e("li",[t._v("利用CSS的filter和transition在图片完全加载前实现模糊特效。")]),t._v(" "),e("li",[t._v("利用库react-progressive-graceful-image进行图片加载，其中用到render props(render prop 是一个用于告知组件需要渲染什么内容的函数 prop。)")])]),t._v(" "),e("h1",{attrs:{id:"tip"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tip"}},[t._v("#")]),t._v(" Tip")]),t._v(" "),e("h2",{attrs:{id:"css-布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css-布局"}},[t._v("#")]),t._v(" css 布局")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("flex布局设置一行有几个")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("display: flex;\nflex: 1 1 50%;\nflex-wrap: nowrap\n")])])])]),t._v(" "),e("li",[e("p",[t._v("css 利用伪元素，默认是inline行内元素无宽高(所以看不见)，需要变成块状元素才能对它设置。另外inline-block是同一行显示，block是非同行显示")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(".t {\n\t&::after,\n\t::before{\n\t\t\tdisplay: inline-block / block / flex\n\t}\n}\n")])])])])])])}),[],!1,null,null,null);e.default=n.exports}}]);